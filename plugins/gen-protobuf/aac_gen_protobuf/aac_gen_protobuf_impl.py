"""AaC Plugin implementation module for the aac-gen-protobuf plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.
from iteration_utilities import flatten

from aac import parser, util
from aac.template_engine import (TemplateOutputFile, generate_template,
                                 load_templates,
                                 write_generated_templates_to_file)

plugin_version = "0.0.1"


def gen_protobuf(architecture_file: str, output_directory: str):
    """
    Generate protobuf messages from Arch-as-Code models.

    Args:
        architecture_file <str>: TODO add a helpful parameter description
        output_directory <str>: TODO add a helpful parameter description
    """
    parsed_models = parser.parse_file(architecture_file)

    loaded_templates = load_templates(__package__)

    data_messages = _collect_data_messages_from_behavior(parsed_models)
    message_template_properties = list(map(_generate_protobuf_details_from_data_message_model, data_messages.values()))
    generated_messages = _generate_protobuf_messages(loaded_templates, message_template_properties)

    templates_to_write = _convert_generated_files_dict_to_template_outputs(generated_messages)
    write_generated_templates_to_file(templates_to_write, output_directory)
    print(f"Succesfully generated templates to directory: {output_directory}")


def _convert_generated_files_dict_to_template_outputs(generated_messages: dict) -> list[TemplateOutputFile]:
    """
    This method should go away once the template engine's interface is updated so that it returns generated templates
        as TemplateOutputFile instead of as strings
    """
    def create_template_output(file_info_dict: dict):
        return TemplateOutputFile(file_info_dict.get("filename"), file_info_dict.get("content"), True)

    return list(map(create_template_output, generated_messages))


def _collect_data_messages_from_behavior(parsed_models: dict):

    def collect_behaviors(model_with_behaviors):
        return util.search(model_with_behaviors, ["model", "behavior"])

    def convert_behavior_io_to_data_type(behavior_io_model):
        return behavior_io_model.get("type")

    def collect_data_message_types(behavior_model):
        inputs = behavior_model.get("input") or []
        outputs = behavior_model.get("output") or []
        return list(map(convert_behavior_io_to_data_type, inputs + outputs))

    model_definitions = util.get_models_by_type(parsed_models, "model")
    behaviors = list(flatten(map(collect_behaviors, model_definitions.values())))
    data_message_types = set(flatten(map(collect_data_message_types, behaviors)))

    return {data_message_type: parsed_models[data_message_type] for data_message_type in data_message_types}


def _generate_protobuf_details_from_data_message_model(data_message_model) -> dict:
    """
    Produces a dict of protobuf template properties based on the data message model
    """
    message_name = data_message_model["data"]["name"]
    fields = data_message_model["data"]["fields"]

    message_fields = []
    for field in fields:
        # if "protobuf_type" not in field:
            # TODO: Sort this exception
            # raise GenerateProtobufException(f"{message_name} doesn't not specify a protobuf_type for the field {field}")

        field_name = field.get("name")
        field_type = field.get("protobuf_type") or field.get("type")
        message_fields.append({"name": field_name, "type": field_type})

    message_properties = {
        "name": message_name,
        "fields": message_fields
    }

    return message_properties


def _convert_camel_case_to_snake_case(camel_case_str: str):
    """
    Converts a camelCase string to a snake_case string.
    """
    snake_case_str = camel_case_str[:1].lower()
    for char in camel_case_str[1:]:
        snake_case_str += (char, f"_{char.lower()}")[char.isupper()]
    return snake_case_str


def _generate_protobuf_messages(protobuf_message_templates, properties) -> list:
    """
    Compiles templates and file information.

    File and general structure style will follow the google protobuf style which can be found at
        https://developers.google.com/protocol-buffers/docs/style

    Returns:
        list of template information dictionaries.
    """

    def convert_message_name_to_file_name(message_name: str):
        new_file_name = f"{message_name}.proto"
        new_file_name = new_file_name.replace("- ", "_")
        new_file_name = _convert_camel_case_to_snake_case(new_file_name)
        return new_file_name

    def generate_protobuf_message_from_template(properties) -> list:
        return [{"filename": convert_message_name_to_file_name(properties.get("name")), "content": generate_template(protobuf_template, properties)}]

    # This plugin produces only protobuf messages and one message per file due to protobuf specifications
    protobuf_template = None
    if len(protobuf_message_templates) != 1:
        raise GenerateProtobufException(f"Unexpected number of templates loaded {len(protobuf_message_templates)}, \
                    expecting only protobuf message template. Loaded templates: {protobuf_message_templates}")
    else:
        protobuf_template = protobuf_message_templates[0]

    return list(flatten(map(generate_protobuf_message_from_template, properties)))


class GenerateProtobufException(Exception):
    """Exceptions specifically concerning protobuf message generation."""

    pass
