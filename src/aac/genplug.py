import os
import yaml
import aac
from aac import util
from aac.AacCommand import AacCommand


@aac.hookimpl
def get_commands():
    my_cmd = AacCommand("gen-plugin", "Generates an AaC plugin from an AaC model of the plugin", genPlugin)
    return [my_cmd]


@aac.hookimpl
def get_base_model_extensions():
    return '''
ext:
   name: CommandBehaviorType
   type: BehaviorType
   enumExt:
      add:
         - command
'''


def genPlugin(arch_file, parsed_model):

    # ask the user a few questions about their new plugin
    plug_dir = os.path.dirname(os.path.realpath(arch_file))
    confirmation = ""
    first = True
    while confirmation not in ["y", "n", "Y", "N"]:
        if not first:
            print(f"Unrecognized input {confirmation}:  please enter 'y' or 'n'.")
        confirmation = input(f"Do you want to generate an AaC plugin in the directory {plug_dir}? [y/n]")

    if confirmation in ["n", "N"]:
        print(f"Canceled: Please move {arch_file} to the desired directory and rerun the command.")
        return
    else:
        plugin_add_command_lines = []

        # ensure model is present and valid, get the plugin name
        model_types = util.getModelsByType(parsed_model, "model")
        plugin_name = get_plugin_name(model_types, arch_file)

        plugin_add_command_lines, plugin_impl_lines, impl_names = process_behaviors(
            plugin_name, util.search(model_types[plugin_name], ["model", "behavior"]))

        # write files
        # 1) create empty __init__.py
        write_file(plug_dir, "__init__.py", True, ["# WARNIG - Do not edit this file.  Changes may be overwritten by AaC gen-plugin."])
        # 2) write setup.py
        write_file(plug_dir, "setup.py", True, generate_setup_py(plugin_name))
        # 3) write [name].py
        file_name = plugin_name.replace("-", "_")
        write_file(plug_dir, f"{file_name}.py", True, generate_plugin_py(
            plugin_name, impl_names, plugin_add_command_lines, process_extensions(util.getModelsByType(parsed_model, "ext"))))
        # 4) write [name]_impl.py
        plugin_impl_header = ["# NOTE: It is safe to edit this file.  It will not be overritten by AaC gen-plugin", ""]
        write_file(plug_dir, f"{file_name}_impl.py", False, plugin_impl_header + plugin_impl_lines)


def get_plugin_name(models, arch_file):
    # the plugin must have a model to be valid
    # the model doesn't have to define behavior, but it does have to be named
    # since the model is where we get the name from, we'll process that first
    # see if there's a behavior component to this plugin
    if len(models.keys()) != 1:
        print(f"gen-plugin error [{arch_file}]:  Plugin Arch-as-Code yaml must contain a single model.")
        raise RuntimeError
    for plugin_name in models:
        # the plugin name is the name of the first (and only) model
        return plugin_name


def generate_setup_py(plugin_name):
    setup_py_lines = []
    setup_py_lines.append("# WARNIG - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED\n")
    setup_py_lines.append("# This file is auto-generated by aac gen-plugin and may be overwritten.\n")
    setup_py_lines.append("\n")
    setup_py_lines.append("from setuptools import setup")
    setup_py_lines.append("\n")
    from_name = plugin_name.replace("-", "_") + "_impl"
    setup_py_lines.append(f"from {from_name} import plugin_version")
    setup_py_lines.append("\n")
    setup_py_content = f'''
setup(
    version=plugin_version,
    name="{plugin_name}",
    install_requires=["aac"],
    entry_points={{
        "aac": ["{plugin_name}={plugin_name.replace("-", "_")}"],
    }},
)
'''
    setup_py_lines.append(setup_py_content)
    return setup_py_lines


def generate_plugin_py(plugin_name, impl_names, plugin_add_command_lines, plugin_get_extension_lines):
    plugin_lines = []
    plugin_lines.append("# WARNIG - DO NOT EDIT - YOUR CHANGES WILL NOT BE PROTECTED\n")
    plugin_lines.append("# This file is auto-generated by aac gen-plugin and may be overwritten.\n")
    plugin_lines.append("\n")
    plugin_lines.append("import aac\n")
    plugin_lines.append("from aac.AacCommand import AacCommand\n")
    import_name = plugin_name.replace("-", "_")
    import_str = f"from {import_name}_impl import "
    isFirst = True
    for name in impl_names:
        if isFirst:
            isFirst = False
            import_str += name
        else:
            import_str = f"{import_str}, {name}"

    plugin_lines.append(f"{import_str}\n")
    plugin_lines.append("\n")
    plugin_lines.append("\n")
    if len(plugin_add_command_lines) > 0:
        plugin_lines = plugin_lines + plugin_add_command_lines
        plugin_lines.append("\n")
    if len(plugin_get_extension_lines) > 0:
        plugin_lines = plugin_lines + plugin_get_extension_lines
        plugin_lines.append("\n")
    return plugin_lines


def process_behaviors(plugin_name, behaviors):
    add_entries = []
    plugin_impl_lines = []
    impl_names = []
    plugin_impl_lines.append("\n")
    plugin_impl_lines.append("plugin_version = \"0.0.1\"")
    plugin_impl_lines.append("\n")

    for behavior in behaviors:

        behavior_name = behavior["name"]
        behavior_description = behavior["description"]
        if behavior_description.startswith("'"):
            behavior_description = behavior_description[1:]
        if behavior_description.endswith("'"):
            behavior_description = behavior_description[:-1]
        impl_name = behavior_name.replace("-", "_")
        impl_names.append(impl_name)

        # add command for behavior
        add_entries.append(f'''
    ret_val.append(AacCommand(
        \"{behavior_name}\",
        \'''
        {behavior_description}
        \''', {impl_name})
    )''')

        # assemble impl lines
        plugin_impl_lines.append("\n")
        plugin_impl_lines.append(f'''
def {impl_name}(archFile, parsed_model):
    # TODO add implementation here
    print("{impl_name} is not implemented")''')
        plugin_impl_lines.append("\n")

    # assemble behavior info for adding commands
    plugin_add_command_lines = []
    plugin_add_command_lines.append("@aac.hookimpl\n")
    plugin_add_command_lines.append("def get_commands():\n")
    plugin_add_command_lines.append("    ret_val = []")
    for add_command_entry in add_entries:
        plugin_add_command_lines.append(add_command_entry)
        plugin_add_command_lines.append("\n")
    plugin_add_command_lines.append("    return ret_val")

    return plugin_add_command_lines, plugin_impl_lines, impl_names


def process_extensions(ext_types):
    plugin_get_extension_lines = []
    if len(ext_types.keys()) != 0:
        ext_yaml_content = []
        for ext_name in ext_types:
            ext_dict = ext_types[ext_name]
            ext_yaml_content.append(yaml.dump(ext_dict))

        # assemble get extension lines
        plugin_get_extension_lines.append("@aac.hookimpl")
        plugin_get_extension_lines.append("def get_extensions() -> list:")
        plugin_get_extension_lines.append("   extensions = []")
        for yaml_entry in ext_yaml_content:
            plugin_get_extension_lines.append(f"   extensions.append({yaml_entry})")
        plugin_get_extension_lines.append("   return extensions")

    return plugin_get_extension_lines


def write_file(path, file_name, overwrite, content):
    file_to_write = os.path.join(path, file_name)
    if not overwrite and os.path.exists(file_to_write):
        print(f"{file_to_write} already exists, skipping write")
    else:
        file = open(file_to_write, 'w')
        file.writelines(content)
        file.close()
